/**
 * Module dependencies
 */

var util = require('util');
var _ = require('@sailshq/lodash');
var bluebird = require('bluebird');
var flaverr = require('flaverr');


/**
 * parley.wrap()
 *
 * Wrap a promise so that, in the event that it rejects, the resulting data
 * is guaranteed to be wrapped in a new Error with a good stack trace.
 *
 * > For performance reasons, if NODE_ENV is "production" and `process.env.DEBUG`
 * > is falsy, then this does NOT rebuild the stack trace-- it just uses the old
 * > one.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * @param {Function} promise
 *        The not-yet-resolved-or-rejected promise to wrap.
 *        This MUST be a Promise instance-- not just any "thenable" such as
 *        a Deferred!
 *
 * @param {Error|Function?} omenOrCaller
 *        Optional reference to an existing omen (Error instance) or the
 *        caller function from an earlier point on the call stack.  (This is
 *        useful for intermediate libraries that want to further improve the
 *        stack trace thrown back up to **THEIR** own userland.)  If omitted,
 *        a new call stack will be generated by instantiating a new Error.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * @returns {Promise}
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * @throws {Error} If there are usage problems or unexpected behavior
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 */

module.exports = function wrap(promise, caller){

  // Lightly sniff to check this is a promise in an effort to try and avoid common mistakes.
  // (This is by no means completely thorough though.)
  if (!_.isObject(promise) || _.isArray(promise) || _.isFunction(promise) || promise.exec) {
    throw new Error('Invalid usage of `.wrap()`.  Expecting the first argument to be a Promise, but instead, got something else: '+util.inspect(promise, {depth:5}));
  }

  // Build & return a new promise.
  return bluebird.promisify(function(done){

    promise.then(function(result){
      // If the provided promise resolves, then just resolve our new promise identically.
      done(undefined, result);
    })
    .catch(function(raw) {
      // But if the provided promise rejects, do the following to build a new Error,
      // then reject our new promise with that.
      flaverr.wrap('E_FROM_WITHIN', raw, caller);
      // TODO

      // flaverr.retrace(omenOrCaller);
      // if (process.env.NODE_ENV !== 'production' || process.env.DEBUG) {
      //   flaverr.wrap(omenOrCaller);
      // }
      // var omen;
      // if (_.isError(omenOrCaller)) {
      //   omen = omenOrCaller;
      // } else if (_.isFunction(omenOrCaller) || omenOrCaller === undefined) {
      //   omen = flaverr.buildOmen(omenOrCaller||wrap);
      // } else {
      //   throw new Error('Unexpected usage of `.getBareTrace()`.  If an argument is supplied, it must be an Error instance or function (the caller to use when generating a new trace).  But instead, got: '+util.inspect(omenOrCaller, {depth: 5}));
      // }
      done(err);
    });//_∏_

  });//_∏_

};
